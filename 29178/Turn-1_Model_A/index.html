<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Maze Game</title>
<style>
    #gameCanvas {
        border: 1px solid black;
        display: block;
        margin: auto;
    }
    body { 
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        background-color: #f0f0f0;
    }
</style>
</head>
<body>
<div id="gameCanvas"></div>
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = 500;
canvas.height = 500;

const cellSize = 20;
const mazeWidth = canvas.width / cellSize;
const mazeHeight = canvas.height / cellSize;

let maze, player;

// Maze generation using recursive backtracker
function generateMaze() {
    maze = Array(mazeHeight).fill().map(() => Array(mazeWidth).fill(true));
    let stack = [{x: 0, y: 0}];
    
    while (stack.length > 0) {
        let current = stack[stack.length - 1];
        let neighbors = [
            {x: current.x, y: current.y - 2},
            {x: current.x + 2, y: current.y},
            {x: current.x, y: current.y + 2},
            {x: current.x - 2, y: current.y}
        ].filter(n => 
            n.y > 0 && n.y < mazeHeight - 1 && 
            n.x > 0 && n.x < mazeWidth - 1 && 
            maze[n.y][n.x]
        );

        if (neighbors.length === 0) {
            stack.pop();
        } else {
            let next = neighbors[Math.floor(Math.random() * neighbors.length)];
            maze[next.y][next.x] = false;
            maze[current.y + (next.y - current.y) / 2][current.x + (next.x - current.x) / 2] = false;
            stack.push(next);
        }
    }
    // Ensure start and end points are open
    maze[0][1] = maze[mazeHeight-1][mazeWidth-2] = false;
}

function drawMaze() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for(let y = 0; y < mazeHeight; y++) {
        for(let x = 0; x < mazeWidth; x++) {
            if(maze[y][x]) {
                ctx.fillStyle = 'black';
                ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
            }
        }
    }
    // Draw player
    ctx.fillStyle = 'red';
    ctx.fillRect(player.x * cellSize, player.y * cellSize, cellSize, cellSize);
}

function movePlayer(dx, dy) {
    const newX = player.x + dx;
    const newY = player.y + dy;
    if (!maze[newY][newX]) {
        player.x = newX;
        player.y = newY;
    }
    drawMaze();
}

document.addEventListener('keydown', (e) => {
    switch(e.key) {
        case 'ArrowUp': movePlayer(0, -1); break;
        case 'ArrowDown': movePlayer(0, 1); break;
        case 'ArrowLeft': movePlayer(-1, 0); break;
        case 'ArrowRight': movePlayer(1, 0); break;
    }
});

function initGame() {
    player = {x: 1, y: 0};
    generateMaze();
    drawMaze();
}

initGame();
</script>
</body>
</html>