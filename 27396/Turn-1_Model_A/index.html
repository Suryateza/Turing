<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Simple Tetris</title>
<style>
    #gameCanvas {
        border: 2px solid black;
        background-color: #f0f0f0;
    }
    body {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        background: #222;
    }
</style>
</head>
<body>
<canvas id="gameCanvas" width="300" height="600"></canvas>
<script>
// Game setup
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const grid = 30;
let gameOver = false;
let score = 0;

// Tetromino shapes
const shapes = [
    [[1,1,1,1]],
    [[1,1],[1,1]],
    [[0,1,0],[1,1,1]],
    [[1,1,0],[0,1,1]],
    [[0,1,1],[1,1,0]]
];

// Colors for shapes
const colors = ['cyan', 'yellow', 'purple', 'green', 'red'];

// Current piece
let piece = {
    x: 4, 
    y: 0, 
    shape: shapes[Math.floor(Math.random() * shapes.length)]
};

function drawSquare(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * grid, y * grid, grid - 1, grid - 1);
}

function drawBoard() {
    for (let y = 0; y < 20; y++) {
        for (let x = 0; x < 10; x++) {
            drawSquare(x, y, '#ccc');
        }
    }
}

function drawPiece(piece, offsetX = 0, offsetY = 0) {
    piece.shape.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value) {
                drawSquare(piece.x + x + offsetX, piece.y + y + offsetY, colors[shapes.indexOf(piece.shape)]);
            }
        });
    });
}

function collision(board, piece) {
    for (let y = 0; y < piece.shape.length; ++y) {
        for (let x = 0; x < piece.shape[y].length; ++x) {
            if (piece.shape[y][x] && 
                ((board[piece.y + y] && board[piece.y + y][piece.x + x]) !== 0)) {
                return true;
            }
        }
    }
    return false;
}

function mergePieceToBoard(board, piece) {
    piece.shape.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value) {
                board[piece.y + y][piece.x + x] = colors[shapes.indexOf(piece.shape)];
            }
        });
    });
}

function clearLines(board) {
    let linesCleared = 0;
    for (let y = board.length - 1; y >= 0; y--) {
        if (board[y].every(cell => cell !== '#ccc')) {
            board.splice(y, 1);
            board.unshift(new Array(10).fill('#ccc'));
            linesCleared++;
            score += 100;
        }
    }
    return linesCleared;
}

function newPiece() {
    piece.x = 4;
    piece.y = 0;
    piece.shape = shapes[Math.floor(Math.random() * shapes.length)];
    if (collision([], piece)) {
        gameOver = true;
    }
}

// Game loop
function gameLoop() {
    if (gameOver) {
        ctx.fillStyle = "black";
        ctx.fillRect(0, canvas.height / 2 - 30, canvas.width, 60);
        ctx.fillStyle = "white";
        ctx.font = "30px Arial";
        ctx.fillText("Game Over", canvas.width / 2 - 70, canvas.height / 2);
        return;
    }

    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw current state
    drawBoard();
    drawPiece(piece);

    // Move piece down
    piece.y += 1;
    if (collision([], piece)) {
        piece.y -= 1;
        mergePieceToBoard([], piece);
        clearLines([]);
        newPiece();
    }

    requestAnimationFrame(gameLoop);
}

// Controls
document.addEventListener('keydown', event => {
    if (gameOver) return;
    if (event.key === 'ArrowLeft' && piece.x > 0) piece.x -= 1;
    if (event.key === 'ArrowRight' && piece.x < 9 - piece.shape[0].length) piece.x += 1;
    if (event.key === 'ArrowDown') piece.y += 1;
    if (event.key === 'ArrowUp') {
        // Rotate piece
        let rotated = piece.shape[0].map((val, index) => piece.shape.map(row => row[index]).reverse());
        let previousShape = piece.shape;
        piece.shape = rotated;
        if (collision([], piece)) piece.shape = previousShape;
    }
});

// Start game
newPiece();
gameLoop();
</script>
</body>
</html>